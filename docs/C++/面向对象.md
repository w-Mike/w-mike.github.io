---
layout: default
title: 面向对象(侯捷)
parent: C++
nav_order: 2
last_modified_date: 2022年 10月 13日 星期四 13:02:10 CST


---

# 面向对象（上）

## 3--5  头文件与类的声明，构造函数，参数的传递与返回值，操作符重载与临时对象

source code:

```cpp
// complex.h
```

```cpp
// test.cpp
```

### C与C++:

C 相当于在一个类中操作： 只有一个 object(变量 + 操作变量的函数)

C++ 类相当于有多个 object(变量 + 操作变量的函数) 

---

### inline函数

定义在类内部的函数，会自动变为inline函数的候选人（系统会根据函数的复杂度来决定其是否为inline函数）

定义在类外部的函数，也可以添加inline关键字，来"成为"inline函数

---

### 初始化列表

构造函数，在初始化列表中赋值，是对类成员的初始化，如果在构造函数内部进行赋值，是对类成员的赋值，一个是初始化，一个是赋值。对应变量的初始化和赋值，显然应该直接进行初始化。

---

![](../../docimgs/面向对象_imgs/2022-10-11-18-17-49-image.png)

这两个构造函数是不能重载的，在`complex c1` 创建Complex对象时,编译器不知道该调用那个构造函数。

----

### 类成员常函数

对于类内部的函数的定义

- 是否会改变类中的成员变量的值。
  
  - 不改变  则定义为 const 函数，即 `void func() const {}`
  
  - 改变 则定义为普通函数

----

### 引用传递还是值传递

> 尽量使用引用 传递参数 和 函数返回

关于函数参数的传递

1. 尽量用引用传递

2. 根据是否要在该函数内对传递的参数作出改变来确定是否要定义为 const 引用

函数的返回值

1. 尽量使用引用返回

2. 什么情况下不能返回引用：**返回的变量是在函数体内定义的，其生命周期随着函数的返回就会消亡**，故返回的是一个已经消亡的变量的引用，是没有意义的。

---

### 友元

同一个类的不同对象object，互为友元（可以直接访问类的私有成员变量）

---

### 操作符重载

#### 成员函数操作符重载

操作符左边的对象为：**调用<操作符重载函数>的对象**，右边的对象为：**<操作符重载函数>的参数**  (自增运算符不能这样理解)

成员函数中，调用成员函数的对象为this （废话。。

**左++ 和 右++**

```cpp
 class Data{
    int a,b;
    Data& operator++()//++ob1
    {
        //先加
        a++;//this->a = this->a +1
        b++;//this->b = this->b +1
        //后使用
        return *this;
    }
    //成员函数 重载后置++  ob1++  (先使用 后加)
    //编译器 默认识别 operator++(a,int) //但是a可以用this代替 从而化简 operator++(int)
    Data& operator++(int)//ob1++
    {
        //先使用(备份加之前的值)
        static Data old=*this;

        //后加
        a++;
        b++;

        //返回备份值
        return old;
    }
 }
```

操作符左边的对象为<操作符重载函数>的**第一个参数**，右边的对象为**第二个参数**

> cout,与cin是两个 object，他们的类是 ostream

<img title="" src="../../docimgs/面向对象_imgs/2022-10-11-21-03-17-image.png" alt="" width="430">
